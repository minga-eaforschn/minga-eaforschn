# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"columns and relationships of \"activity\""
type activity {
    coordinates(
        "JSON select path"
        path: String
    ): jsonb
    description: String!
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
    id: uuid!
    image_url: String!
    "An array relationship"
    interactions(
        "distinct select on columns"
        distinct_on: [interaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_order_by!],
        "filter the rows returned"
        where: interaction_bool_exp
    ): [interaction!]!
    "An aggregate relationship"
    interactions_aggregate(
        "distinct select on columns"
        distinct_on: [interaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_order_by!],
        "filter the rows returned"
        where: interaction_bool_exp
    ): interaction_aggregate!
    "An array relationship"
    likes(
        "distinct select on columns"
        distinct_on: [like_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [like_order_by!],
        "filter the rows returned"
        where: like_bool_exp
    ): [like!]!
    "An aggregate relationship"
    likes_aggregate(
        "distinct select on columns"
        distinct_on: [like_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [like_order_by!],
        "filter the rows returned"
        where: like_bool_exp
    ): like_aggregate!
    name: String!
    short_description: String!
    website_url: String
}

"aggregated selection of \"activity\""
type activity_aggregate {
    aggregate: activity_aggregate_fields
    nodes: [activity!]!
}

"aggregate fields of \"activity\""
type activity_aggregate_fields {
    avg: activity_avg_fields
    count(columns: [activity_select_column!], distinct: Boolean): Int!
    max: activity_max_fields
    min: activity_min_fields
    stddev: activity_stddev_fields
    stddev_pop: activity_stddev_pop_fields
    stddev_samp: activity_stddev_samp_fields
    sum: activity_sum_fields
    var_pop: activity_var_pop_fields
    var_samp: activity_var_samp_fields
    variance: activity_variance_fields
}

"aggregate avg on columns"
type activity_avg_fields {
    estimated_costs: Float
    estimated_duration: Float
    estimated_duration_in_hours: Float
    estimated_pricing: Float
    gainable_xp: Float
}

"aggregate max on columns"
type activity_max_fields {
    description: String
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
    id: uuid
    image_url: String
    name: String
    short_description: String
    website_url: String
}

"aggregate min on columns"
type activity_min_fields {
    description: String
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
    id: uuid
    image_url: String
    name: String
    short_description: String
    website_url: String
}

"response of any mutation on the table \"activity\""
type activity_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [activity!]!
}

"columns and relationships of \"activity_status\""
type activity_status {
    value: String!
}

"aggregated selection of \"activity_status\""
type activity_status_aggregate {
    aggregate: activity_status_aggregate_fields
    nodes: [activity_status!]!
}

"aggregate fields of \"activity_status\""
type activity_status_aggregate_fields {
    count(columns: [activity_status_select_column!], distinct: Boolean): Int!
    max: activity_status_max_fields
    min: activity_status_min_fields
}

"aggregate max on columns"
type activity_status_max_fields {
    value: String
}

"aggregate min on columns"
type activity_status_min_fields {
    value: String
}

"response of any mutation on the table \"activity_status\""
type activity_status_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [activity_status!]!
}

"aggregate stddev on columns"
type activity_stddev_fields {
    estimated_costs: Float
    estimated_duration: Float
    estimated_duration_in_hours: Float
    estimated_pricing: Float
    gainable_xp: Float
}

"aggregate stddev_pop on columns"
type activity_stddev_pop_fields {
    estimated_costs: Float
    estimated_duration: Float
    estimated_duration_in_hours: Float
    estimated_pricing: Float
    gainable_xp: Float
}

"aggregate stddev_samp on columns"
type activity_stddev_samp_fields {
    estimated_costs: Float
    estimated_duration: Float
    estimated_duration_in_hours: Float
    estimated_pricing: Float
    gainable_xp: Float
}

"aggregate sum on columns"
type activity_sum_fields {
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
}

"aggregate var_pop on columns"
type activity_var_pop_fields {
    estimated_costs: Float
    estimated_duration: Float
    estimated_duration_in_hours: Float
    estimated_pricing: Float
    gainable_xp: Float
}

"aggregate var_samp on columns"
type activity_var_samp_fields {
    estimated_costs: Float
    estimated_duration: Float
    estimated_duration_in_hours: Float
    estimated_pricing: Float
    gainable_xp: Float
}

"aggregate variance on columns"
type activity_variance_fields {
    estimated_costs: Float
    estimated_duration: Float
    estimated_duration_in_hours: Float
    estimated_pricing: Float
    gainable_xp: Float
}

"columns and relationships of \"interaction\""
type interaction {
    activity_id: uuid!
    id: uuid!
    text: String!
    type: interaction_type_enum!
}

"aggregated selection of \"interaction\""
type interaction_aggregate {
    aggregate: interaction_aggregate_fields
    nodes: [interaction!]!
}

"aggregate fields of \"interaction\""
type interaction_aggregate_fields {
    count(columns: [interaction_select_column!], distinct: Boolean): Int!
    max: interaction_max_fields
    min: interaction_min_fields
}

"aggregate max on columns"
type interaction_max_fields {
    activity_id: uuid
    id: uuid
    text: String
}

"aggregate min on columns"
type interaction_min_fields {
    activity_id: uuid
    id: uuid
    text: String
}

"response of any mutation on the table \"interaction\""
type interaction_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [interaction!]!
}

"columns and relationships of \"interaction_type\""
type interaction_type {
    value: String!
}

"aggregated selection of \"interaction_type\""
type interaction_type_aggregate {
    aggregate: interaction_type_aggregate_fields
    nodes: [interaction_type!]!
}

"aggregate fields of \"interaction_type\""
type interaction_type_aggregate_fields {
    count(columns: [interaction_type_select_column!], distinct: Boolean): Int!
    max: interaction_type_max_fields
    min: interaction_type_min_fields
}

"aggregate max on columns"
type interaction_type_max_fields {
    value: String
}

"aggregate min on columns"
type interaction_type_min_fields {
    value: String
}

"response of any mutation on the table \"interaction_type\""
type interaction_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [interaction_type!]!
}

"columns and relationships of \"like\""
type like {
    activity_id: uuid!
    created_at: timestamptz!
    id: uuid!
    user_id: Int!
}

"aggregated selection of \"like\""
type like_aggregate {
    aggregate: like_aggregate_fields
    nodes: [like!]!
}

"aggregate fields of \"like\""
type like_aggregate_fields {
    avg: like_avg_fields
    count(columns: [like_select_column!], distinct: Boolean): Int!
    max: like_max_fields
    min: like_min_fields
    stddev: like_stddev_fields
    stddev_pop: like_stddev_pop_fields
    stddev_samp: like_stddev_samp_fields
    sum: like_sum_fields
    var_pop: like_var_pop_fields
    var_samp: like_var_samp_fields
    variance: like_variance_fields
}

"aggregate avg on columns"
type like_avg_fields {
    user_id: Float
}

"aggregate max on columns"
type like_max_fields {
    activity_id: uuid
    created_at: timestamptz
    id: uuid
    user_id: Int
}

"aggregate min on columns"
type like_min_fields {
    activity_id: uuid
    created_at: timestamptz
    id: uuid
    user_id: Int
}

"response of any mutation on the table \"like\""
type like_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [like!]!
}

"aggregate stddev on columns"
type like_stddev_fields {
    user_id: Float
}

"aggregate stddev_pop on columns"
type like_stddev_pop_fields {
    user_id: Float
}

"aggregate stddev_samp on columns"
type like_stddev_samp_fields {
    user_id: Float
}

"aggregate sum on columns"
type like_sum_fields {
    user_id: Int
}

"aggregate var_pop on columns"
type like_var_pop_fields {
    user_id: Float
}

"aggregate var_samp on columns"
type like_var_samp_fields {
    user_id: Float
}

"aggregate variance on columns"
type like_variance_fields {
    user_id: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"activity\""
    delete_activity(
        "filter the rows which have to be deleted"
        where: activity_bool_exp!
    ): activity_mutation_response
    "delete single row from the table: \"activity\""
    delete_activity_by_pk(id: uuid!): activity
    "delete data from the table: \"activity_status\""
    delete_activity_status(
        "filter the rows which have to be deleted"
        where: activity_status_bool_exp!
    ): activity_status_mutation_response
    "delete single row from the table: \"activity_status\""
    delete_activity_status_by_pk(value: String!): activity_status
    "delete data from the table: \"interaction\""
    delete_interaction(
        "filter the rows which have to be deleted"
        where: interaction_bool_exp!
    ): interaction_mutation_response
    "delete single row from the table: \"interaction\""
    delete_interaction_by_pk(id: uuid!): interaction
    "delete data from the table: \"interaction_type\""
    delete_interaction_type(
        "filter the rows which have to be deleted"
        where: interaction_type_bool_exp!
    ): interaction_type_mutation_response
    "delete single row from the table: \"interaction_type\""
    delete_interaction_type_by_pk(value: String!): interaction_type
    "delete data from the table: \"like\""
    delete_like(
        "filter the rows which have to be deleted"
        where: like_bool_exp!
    ): like_mutation_response
    "delete single row from the table: \"like\""
    delete_like_by_pk(id: uuid!): like
    "delete data from the table: \"owner\""
    delete_owner(
        "filter the rows which have to be deleted"
        where: owner_bool_exp!
    ): owner_mutation_response
    "delete single row from the table: \"owner\""
    delete_owner_by_pk(id: bigint!): owner
    "delete data from the table: \"pet\""
    delete_pet(
        "filter the rows which have to be deleted"
        where: pet_bool_exp!
    ): pet_mutation_response
    "delete single row from the table: \"pet\""
    delete_pet_by_pk(id: Int!): pet
    "delete data from the table: \"user\""
    delete_user(
        "filter the rows which have to be deleted"
        where: user_bool_exp!
    ): user_mutation_response
    "delete data from the table: \"user_activity\""
    delete_user_activity(
        "filter the rows which have to be deleted"
        where: user_activity_bool_exp!
    ): user_activity_mutation_response
    "delete single row from the table: \"user_activity\""
    delete_user_activity_by_pk(id: Int!): user_activity
    "delete single row from the table: \"user\""
    delete_user_by_pk(id: Int!): user
    "insert data into the table: \"activity\""
    insert_activity(
        "the rows to be inserted"
        objects: [activity_insert_input!]!,
        "upsert condition"
        on_conflict: activity_on_conflict
    ): activity_mutation_response
    "insert a single row into the table: \"activity\""
    insert_activity_one(
        "the row to be inserted"
        object: activity_insert_input!,
        "upsert condition"
        on_conflict: activity_on_conflict
    ): activity
    "insert data into the table: \"activity_status\""
    insert_activity_status(
        "the rows to be inserted"
        objects: [activity_status_insert_input!]!,
        "upsert condition"
        on_conflict: activity_status_on_conflict
    ): activity_status_mutation_response
    "insert a single row into the table: \"activity_status\""
    insert_activity_status_one(
        "the row to be inserted"
        object: activity_status_insert_input!,
        "upsert condition"
        on_conflict: activity_status_on_conflict
    ): activity_status
    "insert data into the table: \"interaction\""
    insert_interaction(
        "the rows to be inserted"
        objects: [interaction_insert_input!]!,
        "upsert condition"
        on_conflict: interaction_on_conflict
    ): interaction_mutation_response
    "insert a single row into the table: \"interaction\""
    insert_interaction_one(
        "the row to be inserted"
        object: interaction_insert_input!,
        "upsert condition"
        on_conflict: interaction_on_conflict
    ): interaction
    "insert data into the table: \"interaction_type\""
    insert_interaction_type(
        "the rows to be inserted"
        objects: [interaction_type_insert_input!]!,
        "upsert condition"
        on_conflict: interaction_type_on_conflict
    ): interaction_type_mutation_response
    "insert a single row into the table: \"interaction_type\""
    insert_interaction_type_one(
        "the row to be inserted"
        object: interaction_type_insert_input!,
        "upsert condition"
        on_conflict: interaction_type_on_conflict
    ): interaction_type
    "insert data into the table: \"like\""
    insert_like(
        "the rows to be inserted"
        objects: [like_insert_input!]!,
        "upsert condition"
        on_conflict: like_on_conflict
    ): like_mutation_response
    "insert a single row into the table: \"like\""
    insert_like_one(
        "the row to be inserted"
        object: like_insert_input!,
        "upsert condition"
        on_conflict: like_on_conflict
    ): like
    "insert data into the table: \"owner\""
    insert_owner(
        "the rows to be inserted"
        objects: [owner_insert_input!]!,
        "upsert condition"
        on_conflict: owner_on_conflict
    ): owner_mutation_response
    "insert a single row into the table: \"owner\""
    insert_owner_one(
        "the row to be inserted"
        object: owner_insert_input!,
        "upsert condition"
        on_conflict: owner_on_conflict
    ): owner
    "insert data into the table: \"pet\""
    insert_pet(
        "the rows to be inserted"
        objects: [pet_insert_input!]!,
        "upsert condition"
        on_conflict: pet_on_conflict
    ): pet_mutation_response
    "insert a single row into the table: \"pet\""
    insert_pet_one(
        "the row to be inserted"
        object: pet_insert_input!,
        "upsert condition"
        on_conflict: pet_on_conflict
    ): pet
    "insert data into the table: \"user\""
    insert_user(
        "the rows to be inserted"
        objects: [user_insert_input!]!,
        "upsert condition"
        on_conflict: user_on_conflict
    ): user_mutation_response
    "insert data into the table: \"user_activity\""
    insert_user_activity(
        "the rows to be inserted"
        objects: [user_activity_insert_input!]!,
        "upsert condition"
        on_conflict: user_activity_on_conflict
    ): user_activity_mutation_response
    "insert a single row into the table: \"user_activity\""
    insert_user_activity_one(
        "the row to be inserted"
        object: user_activity_insert_input!,
        "upsert condition"
        on_conflict: user_activity_on_conflict
    ): user_activity
    "insert a single row into the table: \"user\""
    insert_user_one(
        "the row to be inserted"
        object: user_insert_input!,
        "upsert condition"
        on_conflict: user_on_conflict
    ): user
    "update data of the table: \"activity\""
    update_activity(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: activity_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: activity_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: activity_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: activity_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: activity_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: activity_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: activity_set_input,
        "filter the rows which have to be updated"
        where: activity_bool_exp!
    ): activity_mutation_response
    "update single row of the table: \"activity\""
    update_activity_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: activity_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: activity_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: activity_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: activity_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: activity_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: activity_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: activity_set_input,
        pk_columns: activity_pk_columns_input!
    ): activity
    "update multiples rows of table: \"activity\""
    update_activity_many(
        "updates to execute, in order"
        updates: [activity_updates!]!
    ): [activity_mutation_response]
    "update data of the table: \"activity_status\""
    update_activity_status(
        "sets the columns of the filtered rows to the given values"
        _set: activity_status_set_input,
        "filter the rows which have to be updated"
        where: activity_status_bool_exp!
    ): activity_status_mutation_response
    "update single row of the table: \"activity_status\""
    update_activity_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: activity_status_set_input,
        pk_columns: activity_status_pk_columns_input!
    ): activity_status
    "update multiples rows of table: \"activity_status\""
    update_activity_status_many(
        "updates to execute, in order"
        updates: [activity_status_updates!]!
    ): [activity_status_mutation_response]
    "update data of the table: \"interaction\""
    update_interaction(
        "sets the columns of the filtered rows to the given values"
        _set: interaction_set_input,
        "filter the rows which have to be updated"
        where: interaction_bool_exp!
    ): interaction_mutation_response
    "update single row of the table: \"interaction\""
    update_interaction_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: interaction_set_input,
        pk_columns: interaction_pk_columns_input!
    ): interaction
    "update multiples rows of table: \"interaction\""
    update_interaction_many(
        "updates to execute, in order"
        updates: [interaction_updates!]!
    ): [interaction_mutation_response]
    "update data of the table: \"interaction_type\""
    update_interaction_type(
        "sets the columns of the filtered rows to the given values"
        _set: interaction_type_set_input,
        "filter the rows which have to be updated"
        where: interaction_type_bool_exp!
    ): interaction_type_mutation_response
    "update single row of the table: \"interaction_type\""
    update_interaction_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: interaction_type_set_input,
        pk_columns: interaction_type_pk_columns_input!
    ): interaction_type
    "update multiples rows of table: \"interaction_type\""
    update_interaction_type_many(
        "updates to execute, in order"
        updates: [interaction_type_updates!]!
    ): [interaction_type_mutation_response]
    "update data of the table: \"like\""
    update_like(
        "increments the numeric columns with given value of the filtered values"
        _inc: like_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: like_set_input,
        "filter the rows which have to be updated"
        where: like_bool_exp!
    ): like_mutation_response
    "update single row of the table: \"like\""
    update_like_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: like_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: like_set_input,
        pk_columns: like_pk_columns_input!
    ): like
    "update multiples rows of table: \"like\""
    update_like_many(
        "updates to execute, in order"
        updates: [like_updates!]!
    ): [like_mutation_response]
    "update data of the table: \"owner\""
    update_owner(
        "increments the numeric columns with given value of the filtered values"
        _inc: owner_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: owner_set_input,
        "filter the rows which have to be updated"
        where: owner_bool_exp!
    ): owner_mutation_response
    "update single row of the table: \"owner\""
    update_owner_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: owner_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: owner_set_input,
        pk_columns: owner_pk_columns_input!
    ): owner
    "update multiples rows of table: \"owner\""
    update_owner_many(
        "updates to execute, in order"
        updates: [owner_updates!]!
    ): [owner_mutation_response]
    "update data of the table: \"pet\""
    update_pet(
        "increments the numeric columns with given value of the filtered values"
        _inc: pet_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: pet_set_input,
        "filter the rows which have to be updated"
        where: pet_bool_exp!
    ): pet_mutation_response
    "update single row of the table: \"pet\""
    update_pet_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: pet_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: pet_set_input,
        pk_columns: pet_pk_columns_input!
    ): pet
    "update multiples rows of table: \"pet\""
    update_pet_many(
        "updates to execute, in order"
        updates: [pet_updates!]!
    ): [pet_mutation_response]
    "update data of the table: \"user\""
    update_user(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_set_input,
        "filter the rows which have to be updated"
        where: user_bool_exp!
    ): user_mutation_response
    "update data of the table: \"user_activity\""
    update_user_activity(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_activity_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_activity_set_input,
        "filter the rows which have to be updated"
        where: user_activity_bool_exp!
    ): user_activity_mutation_response
    "update single row of the table: \"user_activity\""
    update_user_activity_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_activity_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_activity_set_input,
        pk_columns: user_activity_pk_columns_input!
    ): user_activity
    "update multiples rows of table: \"user_activity\""
    update_user_activity_many(
        "updates to execute, in order"
        updates: [user_activity_updates!]!
    ): [user_activity_mutation_response]
    "update single row of the table: \"user\""
    update_user_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_set_input,
        pk_columns: user_pk_columns_input!
    ): user
    "update multiples rows of table: \"user\""
    update_user_many(
        "updates to execute, in order"
        updates: [user_updates!]!
    ): [user_mutation_response]
}

"columns and relationships of \"owner\""
type owner {
    country: String
    created_at: timestamptz
    id: bigint!
    name: String
    "An array relationship"
    pets(
        "distinct select on columns"
        distinct_on: [pet_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [pet_order_by!],
        "filter the rows returned"
        where: pet_bool_exp
    ): [pet!]!
    "An aggregate relationship"
    pets_aggregate(
        "distinct select on columns"
        distinct_on: [pet_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [pet_order_by!],
        "filter the rows returned"
        where: pet_bool_exp
    ): pet_aggregate!
}

"aggregated selection of \"owner\""
type owner_aggregate {
    aggregate: owner_aggregate_fields
    nodes: [owner!]!
}

"aggregate fields of \"owner\""
type owner_aggregate_fields {
    avg: owner_avg_fields
    count(columns: [owner_select_column!], distinct: Boolean): Int!
    max: owner_max_fields
    min: owner_min_fields
    stddev: owner_stddev_fields
    stddev_pop: owner_stddev_pop_fields
    stddev_samp: owner_stddev_samp_fields
    sum: owner_sum_fields
    var_pop: owner_var_pop_fields
    var_samp: owner_var_samp_fields
    variance: owner_variance_fields
}

"aggregate avg on columns"
type owner_avg_fields {
    id: Float
}

"aggregate max on columns"
type owner_max_fields {
    country: String
    created_at: timestamptz
    id: bigint
    name: String
}

"aggregate min on columns"
type owner_min_fields {
    country: String
    created_at: timestamptz
    id: bigint
    name: String
}

"response of any mutation on the table \"owner\""
type owner_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [owner!]!
}

"aggregate stddev on columns"
type owner_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type owner_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type owner_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type owner_sum_fields {
    id: bigint
}

"aggregate var_pop on columns"
type owner_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type owner_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type owner_variance_fields {
    id: Float
}

"columns and relationships of \"pet\""
type pet {
    created_at: timestamptz!
    id: Int!
    name: String!
    "An object relationship"
    owner: owner!
    owner_id: Int!
    type: String!
}

"aggregated selection of \"pet\""
type pet_aggregate {
    aggregate: pet_aggregate_fields
    nodes: [pet!]!
}

"aggregate fields of \"pet\""
type pet_aggregate_fields {
    avg: pet_avg_fields
    count(columns: [pet_select_column!], distinct: Boolean): Int!
    max: pet_max_fields
    min: pet_min_fields
    stddev: pet_stddev_fields
    stddev_pop: pet_stddev_pop_fields
    stddev_samp: pet_stddev_samp_fields
    sum: pet_sum_fields
    var_pop: pet_var_pop_fields
    var_samp: pet_var_samp_fields
    variance: pet_variance_fields
}

"aggregate avg on columns"
type pet_avg_fields {
    id: Float
    owner_id: Float
}

"aggregate max on columns"
type pet_max_fields {
    created_at: timestamptz
    id: Int
    name: String
    owner_id: Int
    type: String
}

"aggregate min on columns"
type pet_min_fields {
    created_at: timestamptz
    id: Int
    name: String
    owner_id: Int
    type: String
}

"response of any mutation on the table \"pet\""
type pet_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [pet!]!
}

"aggregate stddev on columns"
type pet_stddev_fields {
    id: Float
    owner_id: Float
}

"aggregate stddev_pop on columns"
type pet_stddev_pop_fields {
    id: Float
    owner_id: Float
}

"aggregate stddev_samp on columns"
type pet_stddev_samp_fields {
    id: Float
    owner_id: Float
}

"aggregate sum on columns"
type pet_sum_fields {
    id: Int
    owner_id: Int
}

"aggregate var_pop on columns"
type pet_var_pop_fields {
    id: Float
    owner_id: Float
}

"aggregate var_samp on columns"
type pet_var_samp_fields {
    id: Float
    owner_id: Float
}

"aggregate variance on columns"
type pet_variance_fields {
    id: Float
    owner_id: Float
}

type query_root {
    "fetch data from the table: \"activity\""
    activity(
        "distinct select on columns"
        distinct_on: [activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_order_by!],
        "filter the rows returned"
        where: activity_bool_exp
    ): [activity!]!
    "fetch aggregated fields from the table: \"activity\""
    activity_aggregate(
        "distinct select on columns"
        distinct_on: [activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_order_by!],
        "filter the rows returned"
        where: activity_bool_exp
    ): activity_aggregate!
    "fetch data from the table: \"activity\" using primary key columns"
    activity_by_pk(id: uuid!): activity
    "fetch data from the table: \"activity_status\""
    activity_status(
        "distinct select on columns"
        distinct_on: [activity_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_status_order_by!],
        "filter the rows returned"
        where: activity_status_bool_exp
    ): [activity_status!]!
    "fetch aggregated fields from the table: \"activity_status\""
    activity_status_aggregate(
        "distinct select on columns"
        distinct_on: [activity_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_status_order_by!],
        "filter the rows returned"
        where: activity_status_bool_exp
    ): activity_status_aggregate!
    "fetch data from the table: \"activity_status\" using primary key columns"
    activity_status_by_pk(value: String!): activity_status
    "fetch data from the table: \"interaction\""
    interaction(
        "distinct select on columns"
        distinct_on: [interaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_order_by!],
        "filter the rows returned"
        where: interaction_bool_exp
    ): [interaction!]!
    "fetch aggregated fields from the table: \"interaction\""
    interaction_aggregate(
        "distinct select on columns"
        distinct_on: [interaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_order_by!],
        "filter the rows returned"
        where: interaction_bool_exp
    ): interaction_aggregate!
    "fetch data from the table: \"interaction\" using primary key columns"
    interaction_by_pk(id: uuid!): interaction
    "fetch data from the table: \"interaction_type\""
    interaction_type(
        "distinct select on columns"
        distinct_on: [interaction_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_type_order_by!],
        "filter the rows returned"
        where: interaction_type_bool_exp
    ): [interaction_type!]!
    "fetch aggregated fields from the table: \"interaction_type\""
    interaction_type_aggregate(
        "distinct select on columns"
        distinct_on: [interaction_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_type_order_by!],
        "filter the rows returned"
        where: interaction_type_bool_exp
    ): interaction_type_aggregate!
    "fetch data from the table: \"interaction_type\" using primary key columns"
    interaction_type_by_pk(value: String!): interaction_type
    "fetch data from the table: \"like\""
    like(
        "distinct select on columns"
        distinct_on: [like_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [like_order_by!],
        "filter the rows returned"
        where: like_bool_exp
    ): [like!]!
    "fetch aggregated fields from the table: \"like\""
    like_aggregate(
        "distinct select on columns"
        distinct_on: [like_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [like_order_by!],
        "filter the rows returned"
        where: like_bool_exp
    ): like_aggregate!
    "fetch data from the table: \"like\" using primary key columns"
    like_by_pk(id: uuid!): like
    "fetch data from the table: \"owner\""
    owner(
        "distinct select on columns"
        distinct_on: [owner_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [owner_order_by!],
        "filter the rows returned"
        where: owner_bool_exp
    ): [owner!]!
    "fetch aggregated fields from the table: \"owner\""
    owner_aggregate(
        "distinct select on columns"
        distinct_on: [owner_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [owner_order_by!],
        "filter the rows returned"
        where: owner_bool_exp
    ): owner_aggregate!
    "fetch data from the table: \"owner\" using primary key columns"
    owner_by_pk(id: bigint!): owner
    "fetch data from the table: \"pet\""
    pet(
        "distinct select on columns"
        distinct_on: [pet_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [pet_order_by!],
        "filter the rows returned"
        where: pet_bool_exp
    ): [pet!]!
    "fetch aggregated fields from the table: \"pet\""
    pet_aggregate(
        "distinct select on columns"
        distinct_on: [pet_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [pet_order_by!],
        "filter the rows returned"
        where: pet_bool_exp
    ): pet_aggregate!
    "fetch data from the table: \"pet\" using primary key columns"
    pet_by_pk(id: Int!): pet
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): [user!]!
    "fetch data from the table: \"user_activity\""
    user_activity(
        "distinct select on columns"
        distinct_on: [user_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_activity_order_by!],
        "filter the rows returned"
        where: user_activity_bool_exp
    ): [user_activity!]!
    "fetch aggregated fields from the table: \"user_activity\""
    user_activity_aggregate(
        "distinct select on columns"
        distinct_on: [user_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_activity_order_by!],
        "filter the rows returned"
        where: user_activity_bool_exp
    ): user_activity_aggregate!
    "fetch data from the table: \"user_activity\" using primary key columns"
    user_activity_by_pk(id: Int!): user_activity
    "fetch aggregated fields from the table: \"user\""
    user_aggregate(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): user_aggregate!
    "fetch data from the table: \"user\" using primary key columns"
    user_by_pk(id: Int!): user
}

type subscription_root {
    "fetch data from the table: \"activity\""
    activity(
        "distinct select on columns"
        distinct_on: [activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_order_by!],
        "filter the rows returned"
        where: activity_bool_exp
    ): [activity!]!
    "fetch aggregated fields from the table: \"activity\""
    activity_aggregate(
        "distinct select on columns"
        distinct_on: [activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_order_by!],
        "filter the rows returned"
        where: activity_bool_exp
    ): activity_aggregate!
    "fetch data from the table: \"activity\" using primary key columns"
    activity_by_pk(id: uuid!): activity
    "fetch data from the table: \"activity_status\""
    activity_status(
        "distinct select on columns"
        distinct_on: [activity_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_status_order_by!],
        "filter the rows returned"
        where: activity_status_bool_exp
    ): [activity_status!]!
    "fetch aggregated fields from the table: \"activity_status\""
    activity_status_aggregate(
        "distinct select on columns"
        distinct_on: [activity_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_status_order_by!],
        "filter the rows returned"
        where: activity_status_bool_exp
    ): activity_status_aggregate!
    "fetch data from the table: \"activity_status\" using primary key columns"
    activity_status_by_pk(value: String!): activity_status
    "fetch data from the table in a streaming manner: \"activity_status\""
    activity_status_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [activity_status_stream_cursor_input]!,
        "filter the rows returned"
        where: activity_status_bool_exp
    ): [activity_status!]!
    "fetch data from the table in a streaming manner: \"activity\""
    activity_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [activity_stream_cursor_input]!,
        "filter the rows returned"
        where: activity_bool_exp
    ): [activity!]!
    "fetch data from the table: \"interaction\""
    interaction(
        "distinct select on columns"
        distinct_on: [interaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_order_by!],
        "filter the rows returned"
        where: interaction_bool_exp
    ): [interaction!]!
    "fetch aggregated fields from the table: \"interaction\""
    interaction_aggregate(
        "distinct select on columns"
        distinct_on: [interaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_order_by!],
        "filter the rows returned"
        where: interaction_bool_exp
    ): interaction_aggregate!
    "fetch data from the table: \"interaction\" using primary key columns"
    interaction_by_pk(id: uuid!): interaction
    "fetch data from the table in a streaming manner: \"interaction\""
    interaction_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [interaction_stream_cursor_input]!,
        "filter the rows returned"
        where: interaction_bool_exp
    ): [interaction!]!
    "fetch data from the table: \"interaction_type\""
    interaction_type(
        "distinct select on columns"
        distinct_on: [interaction_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_type_order_by!],
        "filter the rows returned"
        where: interaction_type_bool_exp
    ): [interaction_type!]!
    "fetch aggregated fields from the table: \"interaction_type\""
    interaction_type_aggregate(
        "distinct select on columns"
        distinct_on: [interaction_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [interaction_type_order_by!],
        "filter the rows returned"
        where: interaction_type_bool_exp
    ): interaction_type_aggregate!
    "fetch data from the table: \"interaction_type\" using primary key columns"
    interaction_type_by_pk(value: String!): interaction_type
    "fetch data from the table in a streaming manner: \"interaction_type\""
    interaction_type_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [interaction_type_stream_cursor_input]!,
        "filter the rows returned"
        where: interaction_type_bool_exp
    ): [interaction_type!]!
    "fetch data from the table: \"like\""
    like(
        "distinct select on columns"
        distinct_on: [like_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [like_order_by!],
        "filter the rows returned"
        where: like_bool_exp
    ): [like!]!
    "fetch aggregated fields from the table: \"like\""
    like_aggregate(
        "distinct select on columns"
        distinct_on: [like_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [like_order_by!],
        "filter the rows returned"
        where: like_bool_exp
    ): like_aggregate!
    "fetch data from the table: \"like\" using primary key columns"
    like_by_pk(id: uuid!): like
    "fetch data from the table in a streaming manner: \"like\""
    like_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [like_stream_cursor_input]!,
        "filter the rows returned"
        where: like_bool_exp
    ): [like!]!
    "fetch data from the table: \"owner\""
    owner(
        "distinct select on columns"
        distinct_on: [owner_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [owner_order_by!],
        "filter the rows returned"
        where: owner_bool_exp
    ): [owner!]!
    "fetch aggregated fields from the table: \"owner\""
    owner_aggregate(
        "distinct select on columns"
        distinct_on: [owner_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [owner_order_by!],
        "filter the rows returned"
        where: owner_bool_exp
    ): owner_aggregate!
    "fetch data from the table: \"owner\" using primary key columns"
    owner_by_pk(id: bigint!): owner
    "fetch data from the table in a streaming manner: \"owner\""
    owner_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [owner_stream_cursor_input]!,
        "filter the rows returned"
        where: owner_bool_exp
    ): [owner!]!
    "fetch data from the table: \"pet\""
    pet(
        "distinct select on columns"
        distinct_on: [pet_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [pet_order_by!],
        "filter the rows returned"
        where: pet_bool_exp
    ): [pet!]!
    "fetch aggregated fields from the table: \"pet\""
    pet_aggregate(
        "distinct select on columns"
        distinct_on: [pet_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [pet_order_by!],
        "filter the rows returned"
        where: pet_bool_exp
    ): pet_aggregate!
    "fetch data from the table: \"pet\" using primary key columns"
    pet_by_pk(id: Int!): pet
    "fetch data from the table in a streaming manner: \"pet\""
    pet_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [pet_stream_cursor_input]!,
        "filter the rows returned"
        where: pet_bool_exp
    ): [pet!]!
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): [user!]!
    "fetch data from the table: \"user_activity\""
    user_activity(
        "distinct select on columns"
        distinct_on: [user_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_activity_order_by!],
        "filter the rows returned"
        where: user_activity_bool_exp
    ): [user_activity!]!
    "fetch aggregated fields from the table: \"user_activity\""
    user_activity_aggregate(
        "distinct select on columns"
        distinct_on: [user_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_activity_order_by!],
        "filter the rows returned"
        where: user_activity_bool_exp
    ): user_activity_aggregate!
    "fetch data from the table: \"user_activity\" using primary key columns"
    user_activity_by_pk(id: Int!): user_activity
    "fetch data from the table in a streaming manner: \"user_activity\""
    user_activity_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [user_activity_stream_cursor_input]!,
        "filter the rows returned"
        where: user_activity_bool_exp
    ): [user_activity!]!
    "fetch aggregated fields from the table: \"user\""
    user_aggregate(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): user_aggregate!
    "fetch data from the table: \"user\" using primary key columns"
    user_by_pk(id: Int!): user
    "fetch data from the table in a streaming manner: \"user\""
    user_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [user_stream_cursor_input]!,
        "filter the rows returned"
        where: user_bool_exp
    ): [user!]!
}

"columns and relationships of \"user\""
type user {
    id: Int!
    image_url: String!
    name: String!
    total_xp: Int!
    "An array relationship"
    user_activities(
        "distinct select on columns"
        distinct_on: [user_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_activity_order_by!],
        "filter the rows returned"
        where: user_activity_bool_exp
    ): [user_activity!]!
    "An aggregate relationship"
    user_activities_aggregate(
        "distinct select on columns"
        distinct_on: [user_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_activity_order_by!],
        "filter the rows returned"
        where: user_activity_bool_exp
    ): user_activity_aggregate!
}

"columns and relationships of \"user_activity\""
type user_activity {
    "An object relationship"
    activity: activity!
    activity_id: uuid!
    "An object relationship"
    activity_status: activity_status!
    created_at: timestamptz!
    due_to: timestamptz!
    id: Int!
    status: activity_status_enum!
    updated_at: timestamptz!
    user_id: Int!
}

"aggregated selection of \"user_activity\""
type user_activity_aggregate {
    aggregate: user_activity_aggregate_fields
    nodes: [user_activity!]!
}

"aggregate fields of \"user_activity\""
type user_activity_aggregate_fields {
    avg: user_activity_avg_fields
    count(columns: [user_activity_select_column!], distinct: Boolean): Int!
    max: user_activity_max_fields
    min: user_activity_min_fields
    stddev: user_activity_stddev_fields
    stddev_pop: user_activity_stddev_pop_fields
    stddev_samp: user_activity_stddev_samp_fields
    sum: user_activity_sum_fields
    var_pop: user_activity_var_pop_fields
    var_samp: user_activity_var_samp_fields
    variance: user_activity_variance_fields
}

"aggregate avg on columns"
type user_activity_avg_fields {
    id: Float
    user_id: Float
}

"aggregate max on columns"
type user_activity_max_fields {
    activity_id: uuid
    created_at: timestamptz
    due_to: timestamptz
    id: Int
    updated_at: timestamptz
    user_id: Int
}

"aggregate min on columns"
type user_activity_min_fields {
    activity_id: uuid
    created_at: timestamptz
    due_to: timestamptz
    id: Int
    updated_at: timestamptz
    user_id: Int
}

"response of any mutation on the table \"user_activity\""
type user_activity_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_activity!]!
}

"aggregate stddev on columns"
type user_activity_stddev_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_pop on columns"
type user_activity_stddev_pop_fields {
    id: Float
    user_id: Float
}

"aggregate stddev_samp on columns"
type user_activity_stddev_samp_fields {
    id: Float
    user_id: Float
}

"aggregate sum on columns"
type user_activity_sum_fields {
    id: Int
    user_id: Int
}

"aggregate var_pop on columns"
type user_activity_var_pop_fields {
    id: Float
    user_id: Float
}

"aggregate var_samp on columns"
type user_activity_var_samp_fields {
    id: Float
    user_id: Float
}

"aggregate variance on columns"
type user_activity_variance_fields {
    id: Float
    user_id: Float
}

"aggregated selection of \"user\""
type user_aggregate {
    aggregate: user_aggregate_fields
    nodes: [user!]!
}

"aggregate fields of \"user\""
type user_aggregate_fields {
    avg: user_avg_fields
    count(columns: [user_select_column!], distinct: Boolean): Int!
    max: user_max_fields
    min: user_min_fields
    stddev: user_stddev_fields
    stddev_pop: user_stddev_pop_fields
    stddev_samp: user_stddev_samp_fields
    sum: user_sum_fields
    var_pop: user_var_pop_fields
    var_samp: user_var_samp_fields
    variance: user_variance_fields
}

"aggregate avg on columns"
type user_avg_fields {
    id: Float
    total_xp: Float
}

"aggregate max on columns"
type user_max_fields {
    id: Int
    image_url: String
    name: String
    total_xp: Int
}

"aggregate min on columns"
type user_min_fields {
    id: Int
    image_url: String
    name: String
    total_xp: Int
}

"response of any mutation on the table \"user\""
type user_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user!]!
}

"aggregate stddev on columns"
type user_stddev_fields {
    id: Float
    total_xp: Float
}

"aggregate stddev_pop on columns"
type user_stddev_pop_fields {
    id: Float
    total_xp: Float
}

"aggregate stddev_samp on columns"
type user_stddev_samp_fields {
    id: Float
    total_xp: Float
}

"aggregate sum on columns"
type user_sum_fields {
    id: Int
    total_xp: Int
}

"aggregate var_pop on columns"
type user_var_pop_fields {
    id: Float
    total_xp: Float
}

"aggregate var_samp on columns"
type user_var_samp_fields {
    id: Float
    total_xp: Float
}

"aggregate variance on columns"
type user_variance_fields {
    id: Float
    total_xp: Float
}

"unique or primary key constraints on table \"activity\""
enum activity_constraint {
    "unique or primary key constraint on columns \"name\""
    activity_name_key
    "unique or primary key constraint on columns \"id\""
    activity_pkey
}

"select columns of table \"activity\""
enum activity_select_column {
    "column name"
    coordinates
    "column name"
    description
    "column name"
    estimated_costs
    "column name"
    estimated_duration
    "column name"
    estimated_duration_in_hours
    "column name"
    estimated_pricing
    "column name"
    gainable_xp
    "column name"
    id
    "column name"
    image_url
    "column name"
    name
    "column name"
    short_description
    "column name"
    website_url
}

"unique or primary key constraints on table \"activity_status\""
enum activity_status_constraint {
    "unique or primary key constraint on columns \"value\""
    activity_status_pkey
}

enum activity_status_enum {
    DONE
    ONGOING
    OUTSTANDING
}

"select columns of table \"activity_status\""
enum activity_status_select_column {
    "column name"
    value
}

"update columns of table \"activity_status\""
enum activity_status_update_column {
    "column name"
    value
}

"update columns of table \"activity\""
enum activity_update_column {
    "column name"
    coordinates
    "column name"
    description
    "column name"
    estimated_costs
    "column name"
    estimated_duration
    "column name"
    estimated_duration_in_hours
    "column name"
    estimated_pricing
    "column name"
    gainable_xp
    "column name"
    id
    "column name"
    image_url
    "column name"
    name
    "column name"
    short_description
    "column name"
    website_url
}

"ordering argument of a cursor"
enum cursor_ordering {
    "ascending ordering of the cursor"
    ASC
    "descending ordering of the cursor"
    DESC
}

"unique or primary key constraints on table \"interaction\""
enum interaction_constraint {
    "unique or primary key constraint on columns \"id\""
    interaction_pkey
}

"select columns of table \"interaction\""
enum interaction_select_column {
    "column name"
    activity_id
    "column name"
    id
    "column name"
    text
    "column name"
    type
}

"unique or primary key constraints on table \"interaction_type\""
enum interaction_type_constraint {
    "unique or primary key constraint on columns \"value\""
    interaction_type_pkey
}

enum interaction_type_enum {
    FACT
    FUN_FACT
}

"select columns of table \"interaction_type\""
enum interaction_type_select_column {
    "column name"
    value
}

"update columns of table \"interaction_type\""
enum interaction_type_update_column {
    "column name"
    value
}

"update columns of table \"interaction\""
enum interaction_update_column {
    "column name"
    activity_id
    "column name"
    id
    "column name"
    text
    "column name"
    type
}

"unique or primary key constraints on table \"like\""
enum like_constraint {
    "unique or primary key constraint on columns \"id\""
    like_pkey
}

"select columns of table \"like\""
enum like_select_column {
    "column name"
    activity_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    user_id
}

"update columns of table \"like\""
enum like_update_column {
    "column name"
    activity_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    user_id
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"owner\""
enum owner_constraint {
    "unique or primary key constraint on columns \"id\""
    owner_pkey
}

"select columns of table \"owner\""
enum owner_select_column {
    "column name"
    country
    "column name"
    created_at
    "column name"
    id
    "column name"
    name
}

"update columns of table \"owner\""
enum owner_update_column {
    "column name"
    country
    "column name"
    created_at
    "column name"
    id
    "column name"
    name
}

"unique or primary key constraints on table \"pet\""
enum pet_constraint {
    "unique or primary key constraint on columns \"id\""
    pet_pkey
}

"select columns of table \"pet\""
enum pet_select_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    name
    "column name"
    owner_id
    "column name"
    type
}

"update columns of table \"pet\""
enum pet_update_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    name
    "column name"
    owner_id
    "column name"
    type
}

"unique or primary key constraints on table \"user_activity\""
enum user_activity_constraint {
    "unique or primary key constraint on columns \"status\", \"activity_id\", \"user_id\""
    user_activity_activity_id_status_user_id_key
    "unique or primary key constraint on columns \"id\""
    user_activity_pkey
}

"select columns of table \"user_activity\""
enum user_activity_select_column {
    "column name"
    activity_id
    "column name"
    created_at
    "column name"
    due_to
    "column name"
    id
    "column name"
    status
    "column name"
    updated_at
    "column name"
    user_id
}

"update columns of table \"user_activity\""
enum user_activity_update_column {
    "column name"
    activity_id
    "column name"
    created_at
    "column name"
    due_to
    "column name"
    id
    "column name"
    status
    "column name"
    updated_at
    "column name"
    user_id
}

"unique or primary key constraints on table \"user\""
enum user_constraint {
    "unique or primary key constraint on columns \"id\""
    user_pkey
}

"select columns of table \"user\""
enum user_select_column {
    "column name"
    id
    "column name"
    image_url
    "column name"
    name
    "column name"
    total_xp
}

"update columns of table \"user\""
enum user_update_column {
    "column name"
    id
    "column name"
    image_url
    "column name"
    name
    "column name"
    total_xp
}

scalar bigint

scalar float8

scalar jsonb

scalar numeric

scalar timestamptz

scalar uuid

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"append existing jsonb value of filtered columns with new jsonb value"
input activity_append_input {
    coordinates: jsonb
}

"Boolean expression to filter rows from the table \"activity\". All fields are combined with a logical 'AND'."
input activity_bool_exp {
    _and: [activity_bool_exp!]
    _not: activity_bool_exp
    _or: [activity_bool_exp!]
    coordinates: jsonb_comparison_exp
    description: String_comparison_exp
    estimated_costs: float8_comparison_exp
    estimated_duration: float8_comparison_exp
    estimated_duration_in_hours: numeric_comparison_exp
    estimated_pricing: numeric_comparison_exp
    gainable_xp: Int_comparison_exp
    id: uuid_comparison_exp
    image_url: String_comparison_exp
    interactions: interaction_bool_exp
    interactions_aggregate: interaction_aggregate_bool_exp
    likes: like_bool_exp
    likes_aggregate: like_aggregate_bool_exp
    name: String_comparison_exp
    short_description: String_comparison_exp
    website_url: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input activity_delete_at_path_input {
    coordinates: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input activity_delete_elem_input {
    coordinates: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input activity_delete_key_input {
    coordinates: String
}

"input type for incrementing numeric columns in table \"activity\""
input activity_inc_input {
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
}

"input type for inserting data into table \"activity\""
input activity_insert_input {
    coordinates: jsonb
    description: String
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
    id: uuid
    image_url: String
    interactions: interaction_arr_rel_insert_input
    likes: like_arr_rel_insert_input
    name: String
    short_description: String
    website_url: String
}

"input type for inserting object relation for remote table \"activity\""
input activity_obj_rel_insert_input {
    data: activity_insert_input!
    "upsert condition"
    on_conflict: activity_on_conflict
}

"on_conflict condition type for table \"activity\""
input activity_on_conflict {
    constraint: activity_constraint!
    update_columns: [activity_update_column!]! = []
    where: activity_bool_exp
}

"Ordering options when selecting data from \"activity\"."
input activity_order_by {
    coordinates: order_by
    description: order_by
    estimated_costs: order_by
    estimated_duration: order_by
    estimated_duration_in_hours: order_by
    estimated_pricing: order_by
    gainable_xp: order_by
    id: order_by
    image_url: order_by
    interactions_aggregate: interaction_aggregate_order_by
    likes_aggregate: like_aggregate_order_by
    name: order_by
    short_description: order_by
    website_url: order_by
}

"primary key columns input for table: activity"
input activity_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input activity_prepend_input {
    coordinates: jsonb
}

"input type for updating data in table \"activity\""
input activity_set_input {
    coordinates: jsonb
    description: String
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
    id: uuid
    image_url: String
    name: String
    short_description: String
    website_url: String
}

"Boolean expression to filter rows from the table \"activity_status\". All fields are combined with a logical 'AND'."
input activity_status_bool_exp {
    _and: [activity_status_bool_exp!]
    _not: activity_status_bool_exp
    _or: [activity_status_bool_exp!]
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"activity_status_enum\". All fields are combined with logical 'AND'."
input activity_status_enum_comparison_exp {
    _eq: activity_status_enum
    _in: [activity_status_enum!]
    _is_null: Boolean
    _neq: activity_status_enum
    _nin: [activity_status_enum!]
}

"input type for inserting data into table \"activity_status\""
input activity_status_insert_input {
    value: String
}

"input type for inserting object relation for remote table \"activity_status\""
input activity_status_obj_rel_insert_input {
    data: activity_status_insert_input!
    "upsert condition"
    on_conflict: activity_status_on_conflict
}

"on_conflict condition type for table \"activity_status\""
input activity_status_on_conflict {
    constraint: activity_status_constraint!
    update_columns: [activity_status_update_column!]! = []
    where: activity_status_bool_exp
}

"Ordering options when selecting data from \"activity_status\"."
input activity_status_order_by {
    value: order_by
}

"primary key columns input for table: activity_status"
input activity_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"activity_status\""
input activity_status_set_input {
    value: String
}

"Streaming cursor of the table \"activity_status\""
input activity_status_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: activity_status_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input activity_status_stream_cursor_value_input {
    value: String
}

input activity_status_updates {
    "sets the columns of the filtered rows to the given values"
    _set: activity_status_set_input
    where: activity_status_bool_exp!
}

"Streaming cursor of the table \"activity\""
input activity_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: activity_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input activity_stream_cursor_value_input {
    coordinates: jsonb
    description: String
    estimated_costs: float8
    estimated_duration: float8
    estimated_duration_in_hours: numeric
    estimated_pricing: numeric
    gainable_xp: Int
    id: uuid
    image_url: String
    name: String
    short_description: String
    website_url: String
}

input activity_updates {
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: activity_append_input
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: activity_delete_at_path_input
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: activity_delete_elem_input
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: activity_delete_key_input
    "increments the numeric columns with given value of the filtered values"
    _inc: activity_inc_input
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: activity_prepend_input
    "sets the columns of the filtered rows to the given values"
    _set: activity_set_input
    where: activity_bool_exp!
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
    _eq: bigint
    _gt: bigint
    _gte: bigint
    _in: [bigint!]
    _is_null: Boolean
    _lt: bigint
    _lte: bigint
    _neq: bigint
    _nin: [bigint!]
}

"Boolean expression to compare columns of type \"float8\". All fields are combined with logical 'AND'."
input float8_comparison_exp {
    _eq: float8
    _gt: float8
    _gte: float8
    _in: [float8!]
    _is_null: Boolean
    _lt: float8
    _lte: float8
    _neq: float8
    _nin: [float8!]
}

input interaction_aggregate_bool_exp {
    count: interaction_aggregate_bool_exp_count
}

input interaction_aggregate_bool_exp_count {
    arguments: [interaction_select_column!]
    distinct: Boolean
    filter: interaction_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"interaction\""
input interaction_aggregate_order_by {
    count: order_by
    max: interaction_max_order_by
    min: interaction_min_order_by
}

"input type for inserting array relation for remote table \"interaction\""
input interaction_arr_rel_insert_input {
    data: [interaction_insert_input!]!
    "upsert condition"
    on_conflict: interaction_on_conflict
}

"Boolean expression to filter rows from the table \"interaction\". All fields are combined with a logical 'AND'."
input interaction_bool_exp {
    _and: [interaction_bool_exp!]
    _not: interaction_bool_exp
    _or: [interaction_bool_exp!]
    activity_id: uuid_comparison_exp
    id: uuid_comparison_exp
    text: String_comparison_exp
    type: interaction_type_enum_comparison_exp
}

"input type for inserting data into table \"interaction\""
input interaction_insert_input {
    activity_id: uuid
    id: uuid
    text: String
    type: interaction_type_enum
}

"order by max() on columns of table \"interaction\""
input interaction_max_order_by {
    activity_id: order_by
    id: order_by
    text: order_by
}

"order by min() on columns of table \"interaction\""
input interaction_min_order_by {
    activity_id: order_by
    id: order_by
    text: order_by
}

"on_conflict condition type for table \"interaction\""
input interaction_on_conflict {
    constraint: interaction_constraint!
    update_columns: [interaction_update_column!]! = []
    where: interaction_bool_exp
}

"Ordering options when selecting data from \"interaction\"."
input interaction_order_by {
    activity_id: order_by
    id: order_by
    text: order_by
    type: order_by
}

"primary key columns input for table: interaction"
input interaction_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"interaction\""
input interaction_set_input {
    activity_id: uuid
    id: uuid
    text: String
    type: interaction_type_enum
}

"Streaming cursor of the table \"interaction\""
input interaction_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: interaction_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input interaction_stream_cursor_value_input {
    activity_id: uuid
    id: uuid
    text: String
    type: interaction_type_enum
}

"Boolean expression to filter rows from the table \"interaction_type\". All fields are combined with a logical 'AND'."
input interaction_type_bool_exp {
    _and: [interaction_type_bool_exp!]
    _not: interaction_type_bool_exp
    _or: [interaction_type_bool_exp!]
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"interaction_type_enum\". All fields are combined with logical 'AND'."
input interaction_type_enum_comparison_exp {
    _eq: interaction_type_enum
    _in: [interaction_type_enum!]
    _is_null: Boolean
    _neq: interaction_type_enum
    _nin: [interaction_type_enum!]
}

"input type for inserting data into table \"interaction_type\""
input interaction_type_insert_input {
    value: String
}

"on_conflict condition type for table \"interaction_type\""
input interaction_type_on_conflict {
    constraint: interaction_type_constraint!
    update_columns: [interaction_type_update_column!]! = []
    where: interaction_type_bool_exp
}

"Ordering options when selecting data from \"interaction_type\"."
input interaction_type_order_by {
    value: order_by
}

"primary key columns input for table: interaction_type"
input interaction_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"interaction_type\""
input interaction_type_set_input {
    value: String
}

"Streaming cursor of the table \"interaction_type\""
input interaction_type_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: interaction_type_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input interaction_type_stream_cursor_value_input {
    value: String
}

input interaction_type_updates {
    "sets the columns of the filtered rows to the given values"
    _set: interaction_type_set_input
    where: interaction_type_bool_exp!
}

input interaction_updates {
    "sets the columns of the filtered rows to the given values"
    _set: interaction_set_input
    where: interaction_bool_exp!
}

input jsonb_cast_exp {
    String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    _cast: jsonb_cast_exp
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

input like_aggregate_bool_exp {
    count: like_aggregate_bool_exp_count
}

input like_aggregate_bool_exp_count {
    arguments: [like_select_column!]
    distinct: Boolean
    filter: like_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"like\""
input like_aggregate_order_by {
    avg: like_avg_order_by
    count: order_by
    max: like_max_order_by
    min: like_min_order_by
    stddev: like_stddev_order_by
    stddev_pop: like_stddev_pop_order_by
    stddev_samp: like_stddev_samp_order_by
    sum: like_sum_order_by
    var_pop: like_var_pop_order_by
    var_samp: like_var_samp_order_by
    variance: like_variance_order_by
}

"input type for inserting array relation for remote table \"like\""
input like_arr_rel_insert_input {
    data: [like_insert_input!]!
    "upsert condition"
    on_conflict: like_on_conflict
}

"order by avg() on columns of table \"like\""
input like_avg_order_by {
    user_id: order_by
}

"Boolean expression to filter rows from the table \"like\". All fields are combined with a logical 'AND'."
input like_bool_exp {
    _and: [like_bool_exp!]
    _not: like_bool_exp
    _or: [like_bool_exp!]
    activity_id: uuid_comparison_exp
    created_at: timestamptz_comparison_exp
    id: uuid_comparison_exp
    user_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"like\""
input like_inc_input {
    user_id: Int
}

"input type for inserting data into table \"like\""
input like_insert_input {
    activity_id: uuid
    created_at: timestamptz
    id: uuid
    user_id: Int
}

"order by max() on columns of table \"like\""
input like_max_order_by {
    activity_id: order_by
    created_at: order_by
    id: order_by
    user_id: order_by
}

"order by min() on columns of table \"like\""
input like_min_order_by {
    activity_id: order_by
    created_at: order_by
    id: order_by
    user_id: order_by
}

"on_conflict condition type for table \"like\""
input like_on_conflict {
    constraint: like_constraint!
    update_columns: [like_update_column!]! = []
    where: like_bool_exp
}

"Ordering options when selecting data from \"like\"."
input like_order_by {
    activity_id: order_by
    created_at: order_by
    id: order_by
    user_id: order_by
}

"primary key columns input for table: like"
input like_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"like\""
input like_set_input {
    activity_id: uuid
    created_at: timestamptz
    id: uuid
    user_id: Int
}

"order by stddev() on columns of table \"like\""
input like_stddev_order_by {
    user_id: order_by
}

"order by stddev_pop() on columns of table \"like\""
input like_stddev_pop_order_by {
    user_id: order_by
}

"order by stddev_samp() on columns of table \"like\""
input like_stddev_samp_order_by {
    user_id: order_by
}

"Streaming cursor of the table \"like\""
input like_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: like_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input like_stream_cursor_value_input {
    activity_id: uuid
    created_at: timestamptz
    id: uuid
    user_id: Int
}

"order by sum() on columns of table \"like\""
input like_sum_order_by {
    user_id: order_by
}

input like_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: like_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: like_set_input
    where: like_bool_exp!
}

"order by var_pop() on columns of table \"like\""
input like_var_pop_order_by {
    user_id: order_by
}

"order by var_samp() on columns of table \"like\""
input like_var_samp_order_by {
    user_id: order_by
}

"order by variance() on columns of table \"like\""
input like_variance_order_by {
    user_id: order_by
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _is_null: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"Boolean expression to filter rows from the table \"owner\". All fields are combined with a logical 'AND'."
input owner_bool_exp {
    _and: [owner_bool_exp!]
    _not: owner_bool_exp
    _or: [owner_bool_exp!]
    country: String_comparison_exp
    created_at: timestamptz_comparison_exp
    id: bigint_comparison_exp
    name: String_comparison_exp
    pets: pet_bool_exp
    pets_aggregate: pet_aggregate_bool_exp
}

"input type for incrementing numeric columns in table \"owner\""
input owner_inc_input {
    id: bigint
}

"input type for inserting data into table \"owner\""
input owner_insert_input {
    country: String
    created_at: timestamptz
    id: bigint
    name: String
    pets: pet_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"owner\""
input owner_obj_rel_insert_input {
    data: owner_insert_input!
    "upsert condition"
    on_conflict: owner_on_conflict
}

"on_conflict condition type for table \"owner\""
input owner_on_conflict {
    constraint: owner_constraint!
    update_columns: [owner_update_column!]! = []
    where: owner_bool_exp
}

"Ordering options when selecting data from \"owner\"."
input owner_order_by {
    country: order_by
    created_at: order_by
    id: order_by
    name: order_by
    pets_aggregate: pet_aggregate_order_by
}

"primary key columns input for table: owner"
input owner_pk_columns_input {
    id: bigint!
}

"input type for updating data in table \"owner\""
input owner_set_input {
    country: String
    created_at: timestamptz
    id: bigint
    name: String
}

"Streaming cursor of the table \"owner\""
input owner_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: owner_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input owner_stream_cursor_value_input {
    country: String
    created_at: timestamptz
    id: bigint
    name: String
}

input owner_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: owner_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: owner_set_input
    where: owner_bool_exp!
}

input pet_aggregate_bool_exp {
    count: pet_aggregate_bool_exp_count
}

input pet_aggregate_bool_exp_count {
    arguments: [pet_select_column!]
    distinct: Boolean
    filter: pet_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"pet\""
input pet_aggregate_order_by {
    avg: pet_avg_order_by
    count: order_by
    max: pet_max_order_by
    min: pet_min_order_by
    stddev: pet_stddev_order_by
    stddev_pop: pet_stddev_pop_order_by
    stddev_samp: pet_stddev_samp_order_by
    sum: pet_sum_order_by
    var_pop: pet_var_pop_order_by
    var_samp: pet_var_samp_order_by
    variance: pet_variance_order_by
}

"input type for inserting array relation for remote table \"pet\""
input pet_arr_rel_insert_input {
    data: [pet_insert_input!]!
    "upsert condition"
    on_conflict: pet_on_conflict
}

"order by avg() on columns of table \"pet\""
input pet_avg_order_by {
    id: order_by
    owner_id: order_by
}

"Boolean expression to filter rows from the table \"pet\". All fields are combined with a logical 'AND'."
input pet_bool_exp {
    _and: [pet_bool_exp!]
    _not: pet_bool_exp
    _or: [pet_bool_exp!]
    created_at: timestamptz_comparison_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    owner: owner_bool_exp
    owner_id: Int_comparison_exp
    type: String_comparison_exp
}

"input type for incrementing numeric columns in table \"pet\""
input pet_inc_input {
    id: Int
    owner_id: Int
}

"input type for inserting data into table \"pet\""
input pet_insert_input {
    created_at: timestamptz
    id: Int
    name: String
    owner: owner_obj_rel_insert_input
    owner_id: Int
    type: String
}

"order by max() on columns of table \"pet\""
input pet_max_order_by {
    created_at: order_by
    id: order_by
    name: order_by
    owner_id: order_by
    type: order_by
}

"order by min() on columns of table \"pet\""
input pet_min_order_by {
    created_at: order_by
    id: order_by
    name: order_by
    owner_id: order_by
    type: order_by
}

"on_conflict condition type for table \"pet\""
input pet_on_conflict {
    constraint: pet_constraint!
    update_columns: [pet_update_column!]! = []
    where: pet_bool_exp
}

"Ordering options when selecting data from \"pet\"."
input pet_order_by {
    created_at: order_by
    id: order_by
    name: order_by
    owner: owner_order_by
    owner_id: order_by
    type: order_by
}

"primary key columns input for table: pet"
input pet_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"pet\""
input pet_set_input {
    created_at: timestamptz
    id: Int
    name: String
    owner_id: Int
    type: String
}

"order by stddev() on columns of table \"pet\""
input pet_stddev_order_by {
    id: order_by
    owner_id: order_by
}

"order by stddev_pop() on columns of table \"pet\""
input pet_stddev_pop_order_by {
    id: order_by
    owner_id: order_by
}

"order by stddev_samp() on columns of table \"pet\""
input pet_stddev_samp_order_by {
    id: order_by
    owner_id: order_by
}

"Streaming cursor of the table \"pet\""
input pet_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: pet_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input pet_stream_cursor_value_input {
    created_at: timestamptz
    id: Int
    name: String
    owner_id: Int
    type: String
}

"order by sum() on columns of table \"pet\""
input pet_sum_order_by {
    id: order_by
    owner_id: order_by
}

input pet_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: pet_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: pet_set_input
    where: pet_bool_exp!
}

"order by var_pop() on columns of table \"pet\""
input pet_var_pop_order_by {
    id: order_by
    owner_id: order_by
}

"order by var_samp() on columns of table \"pet\""
input pet_var_samp_order_by {
    id: order_by
    owner_id: order_by
}

"order by variance() on columns of table \"pet\""
input pet_variance_order_by {
    id: order_by
    owner_id: order_by
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

input user_activity_aggregate_bool_exp {
    count: user_activity_aggregate_bool_exp_count
}

input user_activity_aggregate_bool_exp_count {
    arguments: [user_activity_select_column!]
    distinct: Boolean
    filter: user_activity_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"user_activity\""
input user_activity_aggregate_order_by {
    avg: user_activity_avg_order_by
    count: order_by
    max: user_activity_max_order_by
    min: user_activity_min_order_by
    stddev: user_activity_stddev_order_by
    stddev_pop: user_activity_stddev_pop_order_by
    stddev_samp: user_activity_stddev_samp_order_by
    sum: user_activity_sum_order_by
    var_pop: user_activity_var_pop_order_by
    var_samp: user_activity_var_samp_order_by
    variance: user_activity_variance_order_by
}

"input type for inserting array relation for remote table \"user_activity\""
input user_activity_arr_rel_insert_input {
    data: [user_activity_insert_input!]!
    "upsert condition"
    on_conflict: user_activity_on_conflict
}

"order by avg() on columns of table \"user_activity\""
input user_activity_avg_order_by {
    id: order_by
    user_id: order_by
}

"Boolean expression to filter rows from the table \"user_activity\". All fields are combined with a logical 'AND'."
input user_activity_bool_exp {
    _and: [user_activity_bool_exp!]
    _not: user_activity_bool_exp
    _or: [user_activity_bool_exp!]
    activity: activity_bool_exp
    activity_id: uuid_comparison_exp
    activity_status: activity_status_bool_exp
    created_at: timestamptz_comparison_exp
    due_to: timestamptz_comparison_exp
    id: Int_comparison_exp
    status: activity_status_enum_comparison_exp
    updated_at: timestamptz_comparison_exp
    user_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"user_activity\""
input user_activity_inc_input {
    id: Int
    user_id: Int
}

"input type for inserting data into table \"user_activity\""
input user_activity_insert_input {
    activity: activity_obj_rel_insert_input
    activity_id: uuid
    activity_status: activity_status_obj_rel_insert_input
    created_at: timestamptz
    due_to: timestamptz
    id: Int
    status: activity_status_enum
    updated_at: timestamptz
    user_id: Int
}

"order by max() on columns of table \"user_activity\""
input user_activity_max_order_by {
    activity_id: order_by
    created_at: order_by
    due_to: order_by
    id: order_by
    updated_at: order_by
    user_id: order_by
}

"order by min() on columns of table \"user_activity\""
input user_activity_min_order_by {
    activity_id: order_by
    created_at: order_by
    due_to: order_by
    id: order_by
    updated_at: order_by
    user_id: order_by
}

"on_conflict condition type for table \"user_activity\""
input user_activity_on_conflict {
    constraint: user_activity_constraint!
    update_columns: [user_activity_update_column!]! = []
    where: user_activity_bool_exp
}

"Ordering options when selecting data from \"user_activity\"."
input user_activity_order_by {
    activity: activity_order_by
    activity_id: order_by
    activity_status: activity_status_order_by
    created_at: order_by
    due_to: order_by
    id: order_by
    status: order_by
    updated_at: order_by
    user_id: order_by
}

"primary key columns input for table: user_activity"
input user_activity_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"user_activity\""
input user_activity_set_input {
    activity_id: uuid
    created_at: timestamptz
    due_to: timestamptz
    id: Int
    status: activity_status_enum
    updated_at: timestamptz
    user_id: Int
}

"order by stddev() on columns of table \"user_activity\""
input user_activity_stddev_order_by {
    id: order_by
    user_id: order_by
}

"order by stddev_pop() on columns of table \"user_activity\""
input user_activity_stddev_pop_order_by {
    id: order_by
    user_id: order_by
}

"order by stddev_samp() on columns of table \"user_activity\""
input user_activity_stddev_samp_order_by {
    id: order_by
    user_id: order_by
}

"Streaming cursor of the table \"user_activity\""
input user_activity_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: user_activity_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_activity_stream_cursor_value_input {
    activity_id: uuid
    created_at: timestamptz
    due_to: timestamptz
    id: Int
    status: activity_status_enum
    updated_at: timestamptz
    user_id: Int
}

"order by sum() on columns of table \"user_activity\""
input user_activity_sum_order_by {
    id: order_by
    user_id: order_by
}

input user_activity_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: user_activity_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: user_activity_set_input
    where: user_activity_bool_exp!
}

"order by var_pop() on columns of table \"user_activity\""
input user_activity_var_pop_order_by {
    id: order_by
    user_id: order_by
}

"order by var_samp() on columns of table \"user_activity\""
input user_activity_var_samp_order_by {
    id: order_by
    user_id: order_by
}

"order by variance() on columns of table \"user_activity\""
input user_activity_variance_order_by {
    id: order_by
    user_id: order_by
}

"Boolean expression to filter rows from the table \"user\". All fields are combined with a logical 'AND'."
input user_bool_exp {
    _and: [user_bool_exp!]
    _not: user_bool_exp
    _or: [user_bool_exp!]
    id: Int_comparison_exp
    image_url: String_comparison_exp
    name: String_comparison_exp
    total_xp: Int_comparison_exp
    user_activities: user_activity_bool_exp
    user_activities_aggregate: user_activity_aggregate_bool_exp
}

"input type for incrementing numeric columns in table \"user\""
input user_inc_input {
    id: Int
    total_xp: Int
}

"input type for inserting data into table \"user\""
input user_insert_input {
    id: Int
    image_url: String
    name: String
    total_xp: Int
    user_activities: user_activity_arr_rel_insert_input
}

"on_conflict condition type for table \"user\""
input user_on_conflict {
    constraint: user_constraint!
    update_columns: [user_update_column!]! = []
    where: user_bool_exp
}

"Ordering options when selecting data from \"user\"."
input user_order_by {
    id: order_by
    image_url: order_by
    name: order_by
    total_xp: order_by
    user_activities_aggregate: user_activity_aggregate_order_by
}

"primary key columns input for table: user"
input user_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"user\""
input user_set_input {
    id: Int
    image_url: String
    name: String
    total_xp: Int
}

"Streaming cursor of the table \"user\""
input user_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: user_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_stream_cursor_value_input {
    id: Int
    image_url: String
    name: String
    total_xp: Int
}

input user_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: user_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: user_set_input
    where: user_bool_exp!
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}
